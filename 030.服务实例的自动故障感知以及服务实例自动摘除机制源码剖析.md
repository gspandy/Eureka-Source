 

如果eureka client要停机，你呢要在代码里自己调用DiscoveryClient的shutdown()方法，就会发送请求到eureka server去下线一个服务实例。很多时候，可能不是说你把某个服务给停机了，而是说服务自己宕机了，就不会调用shutdown()方法，也不会去发送请求下线服务实例。

 

eureka自己，有一个所谓到自动故障感知机制，以及服务实例摘除的机制

 

eureka靠的是心跳，来感知，可能某个服务已经挂掉了，就不会再发送心跳了，如果在一段时间内没有接收到某个服务的心跳，那么就将这个服务实例给摘除，认为这个服务实例已经宕机了

 

给大家找一下，自动检查服务实例是否故障宕机的入口：EurekaBootStrap，eureka server在启动初始化的时候，registry.openForTraffic(applicationInfoManager, registryCount);。如果没有我告诉你，你要自己找到这个入口，你该在哪里找呢？你思考一下，如果要启动一个定时检查服务实例有没有宕机的后台线程任务，eureka server启动初始化的时候，会去启动那么一个后台线程。

 

EurekaBootStrap里面找，检查服务实例有没有宕机的这个东西，最可能跟谁是相关的呢？肯定是注册表啊。。。。服务实例信息都在注册表里，registry。所以就在registry相关的地方来寻找一下。eureka代码写的不好，服务实例是否故障宕机的后台检查线程任务，绝对应该是在Registry初始化的过程中来启动。

 

PeerAwareInstanceRegistry.openForTraffic()方法里，最后隐藏了一行调用，postInit()。每隔60s会运行一次定时调度的后台线程任务，EvictionTask。eureka的代码写的很随意，就是没有任何系统设计感，里面一些组件的划分和设计，系统运行流程的设计，都不太清晰和合理。

 com.netflix.eureka.registry.AbstractInstanceRegistry.EvictionTask



对并发的东西大量的使用：volatile、synchronized、ReentractReadWriteLock、Atomic。分布式系统，因为要在内存中保存大量的东西，所以在这里会使用大量的并发编程的这个东西。网上看视频课程，看一些文章，都是并发编程的东西，我平时写业务系统，几乎用不到。

 

用并发编程的东西，都是一些底层的分布式系统，或者是基础框架，分布式系统或者框架，需要在内存中保存很多的数据，只要是在内存中保存的数据，一定会有多线程并发读写的风问题。此时一定是大量的使用并发编程相关的东西。

 

但是如果是那种业务代码，CRUD，基于数据库，来增删改查。

 

但是我们的并发编程，我就压根儿从来了没想过要在前面的地方来讲，因为我是打算到了后面的底层分布式系统研发，基础框架的研发，我们要做这些东西的时候，肯定会大量在内存里基于数据结构来保存各种东西，队列、map、set、list，到时候我们要是对JDK的数据结构的源码来深度剖析。并发编程这一块，我们会大量的使用。

 

讲完这些集合源码、并发包源码，我们再来开发这些底层的基础框架，或者是分布式系统，学完立马在项目里来实战，效果是非常好的。

 

（1）获取一个补偿时间，是为了避免说EvictionTask两次调度的时间超过了设置的60s，***\*补偿时间的机制\****，大家可以学习一下这个东西的使用

 

19:55:00 3分钟 19:58:00 -> 过期

EvictionTask本身调度的就慢了，比上一次该调度的时间晚了92s

19:55:00过后，3分钟内没有心跳，在他延迟的这92s之内，也没心跳，19:59:32，都没心跳发送过，才能认为是失效

 

（2）遍历注册表中所有的服务实例，然后调用Lease的isExpired()方法，来判断当前这个服务实例的租约是否过期了，是否失效了，服务实例故障了，如果是故障的服务实例，加入一个列表。如果上次的心跳到现在间隔了90s * 2 = 180s，3分钟，才会认为是故障了。闪光点，突出你的牛的地方，***\*eureka bug\****。

 

（3）不会一次性将所有故障的服务实例都摘除，每次最多讲注册表中15%的服务实例给摘除掉，所以一次没摘除所有的故障实例，下次EvictionTask再次执行的时候，会再次摘除，***\*分批摘取机制\****

 

（4）在摘除的时候，是从故障实例中随机挑选本次可以摘除的数量的服务实例，来摘除，***\*随机摘取机制\****

 

（5）摘除服务实例的时候，其实就是调用下线的方法，internelCancel()方法，注册表、recentChangeQueue、invalidate缓存

 

 

 